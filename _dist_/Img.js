import './Img.css.proxy.js';
/* src/Img.svelte generated by Svelte v3.29.7 */
import {
	SvelteComponent,
	append,
	assign,
	attr,
	binding_callbacks,
	bubble,
	check_outros,
	compute_rest_props,
	create_slot,
	detach,
	element,
	exclude_internal_props,
	get_spread_update,
	group_outros,
	init,
	insert,
	listen,
	run_all,
	safe_not_equal,
	set_attributes,
	set_style,
	space,
	toggle_class,
	transition_in,
	transition_out,
	update_slot
} from "../web_modules/svelte/internal.js";

import { createEventDispatcher, onMount } from "../web_modules/svelte.js";
const get_error_slot_changes = dirty => ({});
const get_error_slot_context = ctx => ({});
const get_loading_slot_changes = dirty => ({});
const get_loading_slot_context = ctx => ({});

// (86:2) {#if loading}
function create_if_block_1(ctx) {
	let current;
	const loading_slot_template = /*#slots*/ ctx[12].loading;
	const loading_slot = create_slot(loading_slot_template, ctx, /*$$scope*/ ctx[11], get_loading_slot_context);

	return {
		c() {
			if (loading_slot) loading_slot.c();
		},
		m(target, anchor) {
			if (loading_slot) {
				loading_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (loading_slot) {
				if (loading_slot.p && dirty & /*$$scope*/ 2048) {
					update_slot(loading_slot, loading_slot_template, ctx, /*$$scope*/ ctx[11], dirty, get_loading_slot_changes, get_loading_slot_context);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(loading_slot, local);
			current = true;
		},
		o(local) {
			transition_out(loading_slot, local);
			current = false;
		},
		d(detaching) {
			if (loading_slot) loading_slot.d(detaching);
		}
	};
}

// (89:2) {#if error}
function create_if_block(ctx) {
	let current;
	const error_slot_template = /*#slots*/ ctx[12].error;
	const error_slot = create_slot(error_slot_template, ctx, /*$$scope*/ ctx[11], get_error_slot_context);

	return {
		c() {
			if (error_slot) error_slot.c();
		},
		m(target, anchor) {
			if (error_slot) {
				error_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (error_slot) {
				if (error_slot.p && dirty & /*$$scope*/ 2048) {
					update_slot(error_slot, error_slot_template, ctx, /*$$scope*/ ctx[11], dirty, get_error_slot_changes, get_error_slot_context);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(error_slot, local);
			current = true;
		},
		o(local) {
			transition_out(error_slot, local);
			current = false;
		},
		d(detaching) {
			if (error_slot) error_slot.d(detaching);
		}
	};
}

function create_fragment(ctx) {
	let div;
	let t0;
	let t1;
	let img_1;
	let img_1_src_value;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*loading*/ ctx[5] && create_if_block_1(ctx);
	let if_block1 = /*error*/ ctx[6] && create_if_block(ctx);

	let img_1_levels = [
		/*$$restProps*/ ctx[9],
		{ src: img_1_src_value = /*src*/ ctx[0] },
		{ alt: /*alt*/ ctx[1] }
	];

	let img_1_data = {};

	for (let i = 0; i < img_1_levels.length; i += 1) {
		img_1_data = assign(img_1_data, img_1_levels[i]);
	}

	return {
		c() {
			div = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			img_1 = element("img");
			set_attributes(img_1, img_1_data);
			toggle_class(img_1, "loading", /*loading*/ ctx[5] && /*mounted*/ ctx[4]);
			toggle_class(img_1, "hide", /*error*/ ctx[6]);
			toggle_class(img_1, "svelte-lxy8f0", true);
			set_style(div, "padding-bottom", /*height*/ ctx[8] / /*width*/ ctx[7] * 100 + "%");
			set_style(div, "background-color", /*backgroundColor*/ ctx[2]);
			attr(div, "class", "svelte-lxy8f0");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append(div, t0);
			if (if_block1) if_block1.m(div, null);
			append(div, t1);
			append(div, img_1);
			/*img_1_binding*/ ctx[17](img_1);
			current = true;

			if (!mounted) {
				dispose = [
					listen(img_1, "click", /*click_handler*/ ctx[13]),
					listen(img_1, "mouseover", /*mouseover_handler*/ ctx[14]),
					listen(img_1, "mouseenter", /*mouseenter_handler*/ ctx[15]),
					listen(img_1, "mouseout", /*mouseout_handler*/ ctx[16])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (/*loading*/ ctx[5]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*loading*/ 32) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_1(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*error*/ ctx[6]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*error*/ 64) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t1);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			set_attributes(img_1, img_1_data = get_spread_update(img_1_levels, [
				dirty & /*$$restProps*/ 512 && /*$$restProps*/ ctx[9],
				(!current || dirty & /*src*/ 1 && img_1.src !== (img_1_src_value = /*src*/ ctx[0])) && { src: img_1_src_value },
				(!current || dirty & /*alt*/ 2) && { alt: /*alt*/ ctx[1] }
			]));

			toggle_class(img_1, "loading", /*loading*/ ctx[5] && /*mounted*/ ctx[4]);
			toggle_class(img_1, "hide", /*error*/ ctx[6]);
			toggle_class(img_1, "svelte-lxy8f0", true);

			if (!current || dirty & /*height, width*/ 384) {
				set_style(div, "padding-bottom", /*height*/ ctx[8] / /*width*/ ctx[7] * 100 + "%");
			}

			if (!current || dirty & /*backgroundColor*/ 4) {
				set_style(div, "background-color", /*backgroundColor*/ ctx[2]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			/*img_1_binding*/ ctx[17](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	const omit_props_names = ["src","alt","ratio","backgroundColor"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { src = undefined } = $$props;
	let { alt = "" } = $$props;
	let { ratio = "16x9" } = $$props;
	let { backgroundColor = "#f4f4f4" } = $$props;
	const dispatch = createEventDispatcher();
	let img = null;
	let mounted = false;
	let start = -1;
	let timing = 0;
	let loading = true;
	let error = false;

	onMount(() => {
		$$invalidate(4, mounted = true);
	});

	function benchmark(event) {
		$$invalidate(5, loading = false);
		start = 0;
		timing = performance.now() - start;
		dispatch(event, { timing });
	}

	function load() {
		$$invalidate(5, loading = true);
		$$invalidate(6, error = false);
		start = performance.now();
		$$invalidate(3, img.src = src, img);

		$$invalidate(
			3,
			img.onload = () => {
				benchmark("load");
			},
			img
		);

		$$invalidate(
			3,
			img.onerror = () => {
				$$invalidate(6, error = true);
				benchmark("error");
			},
			img
		);
	}

	function click_handler(event) {
		bubble($$self, event);
	}

	function mouseover_handler(event) {
		bubble($$self, event);
	}

	function mouseenter_handler(event) {
		bubble($$self, event);
	}

	function mouseout_handler(event) {
		bubble($$self, event);
	}

	function img_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			img = $$value;
			$$invalidate(3, img);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("src" in $$new_props) $$invalidate(0, src = $$new_props.src);
		if ("alt" in $$new_props) $$invalidate(1, alt = $$new_props.alt);
		if ("ratio" in $$new_props) $$invalidate(10, ratio = $$new_props.ratio);
		if ("backgroundColor" in $$new_props) $$invalidate(2, backgroundColor = $$new_props.backgroundColor);
		if ("$$scope" in $$new_props) $$invalidate(11, $$scope = $$new_props.$$scope);
	};

	let width;
	let height;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*ratio*/ 1024) {
			$: $$invalidate(7, [width, height] = ratio.split("x"), width, ($$invalidate(8, height), $$invalidate(10, ratio)));
		}

		if ($$self.$$.dirty & /*img, src*/ 9) {
			$: if (img && src !== undefined) load();
		}
	};

	return [
		src,
		alt,
		backgroundColor,
		img,
		mounted,
		loading,
		error,
		width,
		height,
		$$restProps,
		ratio,
		$$scope,
		slots,
		click_handler,
		mouseover_handler,
		mouseenter_handler,
		mouseout_handler,
		img_1_binding
	];
}

class Img extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance, create_fragment, safe_not_equal, {
			src: 0,
			alt: 1,
			ratio: 10,
			backgroundColor: 2
		});
	}
}

export default Img;